"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gawk = exports.default = gawk;
exports.isGawked = isGawked;
exports.set = set;
exports.watch = watch;
exports.unwatch = unwatch;
exports.merge = merge;
exports.mergeDeep = mergeDeep;
exports.version = void 0;

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var _fs = _interopRequireDefault(require("fs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// istanbul ignore if
if (!Error.prepareStackTrace) {
  require('source-map-support/register');
}

/**
 * The Gawk version number.
 * @type {String}
 */
const version = JSON.parse(_fs.default.readFileSync(`${__dirname}/../package.json`, 'utf-8')).version;
/**
 * A list of built-in objects that should not be gawked.
 * @type {Array.<Object>}
 */

exports.version = version;
const builtIns = [process.env, Math, JSON];

if (typeof Intl !== 'undefined') {
  builtIns.push(Intl);
}

if (typeof Reflect !== 'undefined') {
  builtIns.push(Reflect);
}
/**
 * Creates a gawk object that wraps the specified object.
 *
 * @param {*} value - A value to gawk.
 * @param {Array|Object} [parent] - The parent gawk object.
 * @returns {Array|Object|*}
 */


function gawk(value, parent) {
  if (parent !== undefined && !isGawked(parent)) {
    throw new TypeError('Expected parent to be gawked');
  } // only objects can be gawked and can't be a built-in object


  if (!value || typeof value !== 'object' || value instanceof Date || builtIns.indexOf(value) !== -1) {
    return value;
  }

  let gawked;

  if (typeof value.__gawk__ === 'object') {
    // already gawked
    if (value === parent) {
      throw new Error('The parent must not be the same object as the value');
    }

    gawked = value;
  } else {
    // gawk it!
    gawked = new Proxy(value, {
      set: (target, prop, newValue) => {
        if (prop === '__gawk__') {
          throw new Error('Cannot override property \'__gawk__\'');
        } // console.log('setting', prop, newValue);


        let changed = true;
        const desc = Object.getOwnPropertyDescriptor(target, prop);

        if (desc) {
          changed = target[prop] !== newValue;

          const parents = isGawked(target[prop]) && target[prop].__gawk__.parents;

          if (parents) {
            parents.delete(gawked);

            if (!parents.size) {
              target[prop].__gawk__.parents = null;
            }
          } // if the destination property has a setter, then we can't assume we need to
          // fire a delete


          if (typeof desc.set !== 'function' && (!Array.isArray(target) || prop !== 'length')) {
            delete target[prop];
          }
        }

        target[prop] = gawk(newValue, gawked);

        if (changed) {
          notify(gawked);
        }

        return true;
      },
      deleteProperty: (target, prop) => {
        if (prop === '__gawk__') {
          throw new Error('Cannot delete property \'__gawk__\'');
        } // console.log('deleting', prop, target[prop]);


        let result = true;

        if (Object.prototype.hasOwnProperty.call(target, prop)) {
          const parents = isGawked(target[prop]) && target[prop].__gawk__.parents;

          if (parents) {
            parents.delete(gawked);

            if (!parents.size) {
              target[prop].__gawk__.parents = null;
            }
          }

          result = delete target[prop];

          if (result) {
            notify(gawked);
          }
        }

        return result;
      }
    });
    Object.defineProperty(gawked, '__gawk__', {
      value: {
        /**
         * A map of listener functions to call invoke when a change occurs. The associated
         * key value is the optional filter to apply to the listener.
         * @type {Map}
         */
        listeners: null,

        /**
         * A list of all the gawk object's parents. These parents are notified when a change
         * occurs.
         * @type {Set}
         */
        parents: null,

        /**
         * A map of listener functions to the last known hash of the stringified value. This
         * is used to detect if a filtered watch should be notified.
         * @type {WeakMap}
         */
        previous: null,

        /**
         * A list of child objects that are modified while paused.
         * @type {Set}
         */
        queue: null,

        /**
         * The Gawk version. This is helpful for identifying the revision of this internal
         * structure.
         * @type {String}
         */
        version,

        /**
         * Dispatches change notifications to the listeners.
         * @returns {Boolean} Returns `true` if it was already paused.
         */
        pause() {
          if (!this.queue) {
            this.queue = new Set();
            return false;
          }

          return true;
        },

        /**
         * Unpauses the gawk notifications and sends out any pending notifications.
         */
        resume() {
          if (this.queue) {
            const queue = this.queue;
            this.queue = null;

            for (const instance of queue) {
              notify(gawked, instance);
            }
          }
        }

      }
    }); // gawk any object properties

    for (const key of Reflect.ownKeys(gawked)) {
      if (key !== '__gawk__' && gawked[key] && typeof gawked[key] === 'object') {
        gawked[key] = gawk(gawked[key], gawked);
      }
    }

    if (Array.isArray(value)) {
      // some array functions do not invoke the delete handler, so we need to override the
      // method and do it ourselves
      const origPop = value.pop;
      const origShift = value.shift;
      const origSplice = value.splice;
      const origUnshift = value.unshift;
      Object.defineProperties(value, {
        pop: {
          configurable: true,
          value: function pop() {
            const wasPaused = this.__gawk__.pause();

            const item = origPop.call(this);
            wasPaused || this.__gawk__.resume();
            return item;
          }
        },
        shift: {
          configurable: true,
          value: function shift() {
            const wasPaused = this.__gawk__.pause();

            const item = origShift.call(this);
            wasPaused || this.__gawk__.resume();
            return item;
          }
        },
        splice: {
          configurable: true,
          value: function splice(start, deleteCount, ...items) {
            const wasPaused = this.__gawk__.pause();

            if (start !== undefined && deleteCount === undefined) {
              deleteCount = this.length - start;
            }

            const arr = origSplice.call(this, start, deleteCount, ...items);

            for (let i = start + items.length; i < this.length; i++) {
              if (this[i] && typeof this[i] === 'object') {
                this[i] = gawk(this[i], this);
              }
            }

            for (const item of arr) {
              if (isGawked(item) && item.__gawk__.parents) {
                item.__gawk__.parents.delete(this);
              }
            }

            wasPaused || this.__gawk__.resume();
            return arr;
          }
        },
        unshift: {
          configurable: true,
          value: function unshift(...items) {
            const wasPaused = this.__gawk__.pause();

            const len = origUnshift.apply(this, items.map(item => gawk(item, this)));
            wasPaused || this.__gawk__.resume();
            return len;
          }
        }
      });
    }
  }

  if (parent) {
    if (!gawked.__gawk__.parents) {
      gawked.__gawk__.parents = new Set();
    }

    gawked.__gawk__.parents.add(parent);
  }

  return gawked;
}

gawk.isGawked = isGawked;
gawk.merge = merge;
gawk.set = set;
gawk.mergeDeep = mergeDeep;
gawk.watch = watch;
gawk.unwatch = unwatch;

/**
 * Determines if the specified variable is gawked.
 *
 * @param {*} it - The variable to check.
 * @returns {Boolean}
 */
function isGawked(it) {
  return !!(it && typeof it === 'object' && it.__gawk__ && typeof it.__gawk__ === 'object');
}
/**
 * Filters the specified gawk object.
 *
 * @param {Object} gobj - A gawked object.
 * @param {Array.<String>} filter - The filter to apply to the gawked object.
 * @returns {Object}
 */


function filterObject(gobj, filter) {
  let found = true;
  let obj = gobj; // find the value we're interested in

  for (let i = 0, len = filter.length; obj && typeof obj === 'object' && i < len; i++) {
    if (!Object.prototype.hasOwnProperty.call(obj, filter[i])) {
      found = false;
      obj = undefined;
      break;
    }

    obj = obj[filter[i]];
  }

  return {
    found,
    obj
  };
}
/**
 * Hashes a value quick and dirty.
 *
 * @param {*} it - A value to hash.
 * @returns {Number}
 */


function hashValue(it) {
  const str = JSON.stringify(it) || '';
  let hash = 5381;
  let i = str.length;

  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }

  return hash >>> 0;
}
/**
 * Dispatches change notifications to the listeners.
 *
 * @param {Object} gobj - The gawked object.
 * @param {Object|Array} [source] - The gawk object that was modified.
 */


function notify(gobj, source) {
  const state = gobj.__gawk__;

  if (source === undefined) {
    source = gobj;
  } // if we're paused, add this object to the list of objects that may have changed


  if (state.queue) {
    state.queue.add(gobj);
    return;
  } // notify all of this object's listeners


  if (state.listeners) {
    for (const [listener, filter] of state.listeners) {
      if (filter) {
        const {
          found,
          obj
        } = filterObject(gobj, filter); // compute the hash of the stringified value

        const hash = hashValue(obj); // check if the value changed

        if (found && !state.previous || state.previous && hash !== state.previous.get(listener)) {
          listener(obj, source);
        }

        if (!state.previous) {
          state.previous = new WeakMap();
        }

        state.previous.set(listener, hash);
      } else {
        listener(gobj, source);
      }
    }
  } // notify all of this object's parents


  if (state.parents) {
    for (const parent of state.parents) {
      notify(parent, source);
    }
  }
}
/**
 * Copies listeners from a source gawked object ot a destination gawked object. Note that the
 * arguments must both be objects and only the `dest` is required to already be gawked.
 *
 * @param {Object|Array} dest - A gawked object to copy the listeners to.
 * @param {Object|Array} src - An object to copy the listeners from.
 * @param {Function} [compareFn] - Doubles up as a deep copy flag and a function to call to compare
 * a source and destination array elements to check if they are the same.
 */


function copyListeners(dest, src, compareFn) {
  if (isGawked(src) && src.__gawk__.listeners) {
    if (dest.__gawk__.listeners) {
      for (const [listener, filter] of src.__gawk__.listeners) {
        dest.__gawk__.listeners.set(listener, filter);
      }
    } else {
      dest.__gawk__.listeners = new Map(src.__gawk__.listeners);
    }
  }

  if (!compareFn) {
    return;
  }

  if (Array.isArray(dest)) {
    const visited = [];

    for (let i = 0, len = dest.length; i < len; i++) {
      if (dest[i] !== null && typeof dest[i] === 'object') {
        // try to find a match in src
        for (let j = 0, len2 = src.length; j < len2; j++) {
          if (!visited[j] && src[j] !== null && typeof src[j] === 'object' && compareFn(dest[i], src[j])) {
            visited[j] = 1;
            copyListeners(dest[i], src[j], compareFn);
            break;
          }
        }
      }
    }

    return;
  }

  for (const key of Object.getOwnPropertyNames(dest)) {
    if (key === '__gawk__') {
      continue;
    }

    if (dest[key] && typeof dest[key] === 'object') {
      copyListeners(dest[key], src[key], compareFn);
    }
  }
}
/**
 * A helper function for replacing the contents of one gawked object with another. It takes care of
 * recursively gawking all decending objects and copying listeners over.
 *
 * @param {Object|Array} dest - The destination gawked object or array.
 * @param {Object|Array} src - The source object or array.
 * @param {Function} [compareFn] - A function to call to compare a source and destination to check
 * if they are the same.
 * @returns {Object|Array} Returns the destination gawked object.
 */


function set(dest, src, compareFn) {
  if (!dest || typeof dest !== 'object') {
    throw new TypeError('Expected destination to be an object');
  }

  if (!src || typeof src !== 'object') {
    // source is not an object, so just return it
    return src;
  }

  if (!compareFn) {
    compareFn = (dest, src) => {
      // note: we purposely do non-strict equality
      return (0, _fastDeepEqual.default)(dest, src);
    };
  } else if (typeof compareFn !== 'function') {
    throw new TypeError('Expected compare callback to be a function');
  }

  const walk = (dest, src, quiet, changed) => {
    // suspend notifications if the dest is a new gawk object
    let wasPaused = false;

    if (!quiet) {
      wasPaused = dest.__gawk__.pause();
    }

    if (Array.isArray(src)) {
      // istanbul ignore if
      if (!Array.isArray(dest)) {
        throw new Error('Source is an array and expected dest to also be an array');
      }

      const visisted = [];

      for (let i = 0, len = src.length; i < len; i++) {
        if (src[i] !== null && typeof src[i] === 'object') {
          src[i] = gawk(src[i]); // try to find a match in dest

          for (let j = 0, len2 = dest.length; j < len2; j++) {
            if (!visisted[j] && dest[j] !== null && typeof dest[j] === 'object' && compareFn(dest[j], src[i])) {
              visisted[j] = 1;
              copyListeners(src[i], dest[j], compareFn);
              break;
            }
          }
        }
      }

      dest.splice(0, dest.length, ...src);
    } else {
      // istanbul ignore if
      if (!dest || typeof dest !== 'object') {
        throw new Error('Source is an object and expected dest to also be an object');
      }

      const tmp = {};

      for (const key of Object.getOwnPropertyNames(src)) {
        if (key === '__gawk__') {
          continue;
        }

        const srcValue = src[key]; // if the source value is not an object, return it now

        if (srcValue === null || typeof srcValue !== 'object') {
          tmp[key] = srcValue;
          continue;
        } // create a new dest object to copy the source into


        const destValue = gawk(Array.isArray(srcValue) ? [] : {});
        tmp[key] = walk(destValue, srcValue, !Object.prototype.hasOwnProperty.call(dest, key));
      } // prune the existing object, then copy all the properties from our temp object


      for (const key of Object.getOwnPropertyNames(dest)) {
        if (key !== '__gawk__') {
          delete dest[key];
        }
      }

      Object.assign(dest, tmp);
    } // copy the listeners


    copyListeners(dest, src); // did dest really change? if not, remove it from the queue

    if (!changed && dest.__gawk__.queue) {
      dest.__gawk__.queue.delete(dest);
    } // resume and send out change notifications


    wasPaused || dest.__gawk__.resume();
    return dest;
  };

  const destIsArray = Array.isArray(dest);
  const srcIsArray = Array.isArray(src);

  if (destIsArray !== srcIsArray) {
    // the type changed and there's no clear way to compare them, so just return a gawked clone
    // of the source
    dest = srcIsArray ? [] : {};
  }

  const gawked = isGawked(dest);
  return walk(gawked ? dest : gawk(dest), src, !gawked, !(0, _fastDeepEqual.default)(dest, src));
}
/**
 * Adds a listener to be called when the specified object or any of its properties/elements are
 * changed.
 *
 * @param {Object|Array} subject - The object to watch.
 * @param {String|Array.<String>} [filter] - A property name or array of nested properties to watch.
 * @param {Function} listener - The function to call when something changes.
 * @returns {Object|Array} Returns a gawked object or array depending on the input object.
 */


function watch(subject, filter, listener) {
  if (!isGawked(subject)) {
    throw new TypeError('Expected subject to be gawked');
  }

  if (typeof filter === 'function') {
    listener = filter;
    filter = null;
  }

  if (filter) {
    if (typeof filter === 'string') {
      filter = [filter];
    } else if (!Array.isArray(filter)) {
      throw new TypeError('Expected filter to be a string or array of strings');
    }
  }

  if (typeof listener !== 'function') {
    throw new TypeError('Expected listener to be a function');
  }

  if (!subject.__gawk__.listeners) {
    subject.__gawk__.listeners = new Map();
  }

  subject.__gawk__.listeners.set(listener, filter);

  if (filter) {
    const {
      found,
      obj
    } = filterObject(subject, filter);

    if (found) {
      const hash = hashValue(obj);

      if (!subject.__gawk__.previous) {
        subject.__gawk__.previous = new WeakMap();
      }

      subject.__gawk__.previous.set(listener, hash);
    }
  }

  return subject;
}
/**
 * Removes a listener from the specified gawked object.
 *
 * @param {Object|Array} subject - The object to unwatch.
 * @param {Function} [listener] - The function to call when something changes.
 * @returns {Object|Array} Returns a gawked object or array depending on the input object.
 */


function unwatch(subject, listener) {
  if (!isGawked(subject)) {
    throw new TypeError('Expected subject to be gawked');
  }

  if (listener && typeof listener !== 'function') {
    throw new TypeError('Expected listener to be a function');
  }

  const g = subject.__gawk__;

  if (g.listeners) {
    if (listener) {
      g.listeners.delete(listener);

      if (g.previous) {
        g.previous.delete(listener);
      }
    } else {
      // remove all listeners
      for (const [listener, filter] of g.listeners) {
        g.listeners.delete(listener);

        if (g.previous) {
          g.previous.delete(listener);
        }
      }
    }

    if (!g.listeners.size) {
      g.listeners = null;
      g.previous = null;
    }
  }

  return subject;
}
/**
 * Mixes an array of objects or gawked objects into the specified gawked object.
 *
 * @param {Array.<Object>} objs - An array of objects or gawked objects.
 * @param {Boolean} [deep=false] - When true, mixes subobjects into each other.
 * @returns {Object}
 */


function mix(objs, deep) {
  const gobj = gawk(objs.shift());

  if (!isGawked(gobj) || Array.isArray(gobj)) {
    throw new TypeError('Expected destination to be a gawked object');
  }

  if (!objs.length) {
    return gobj;
  } // validate the objects are good


  for (const obj of objs) {
    if (!obj || typeof obj !== 'object' || Array.isArray(obj)) {
      throw new TypeError('Expected merge source to be an object');
    }
  } // we need to detach the parent and all listeners so that they will be notified after everything
  // has been merged


  gobj.__gawk__.pause();
  /**
   * Mix an object or gawked object into a gawked object.
   * @param {Object} gobj - The destination gawked object.
   * @param {Object} src - The source object to copy from.
   */


  const mixer = (gobj, src) => {
    for (const key of Object.getOwnPropertyNames(src)) {
      if (key === '__gawk__') {
        continue;
      }

      const srcValue = src[key];

      if (deep && srcValue !== null && typeof srcValue === 'object' && !Array.isArray(srcValue)) {
        if (!isGawked(gobj[key])) {
          gobj[key] = gawk({}, gobj);
        }

        mixer(gobj[key], srcValue);
      } else if (Array.isArray(gobj[key]) && Array.isArray(srcValue)) {
        // overwrite destination with new values
        gobj[key].splice(0, gobj[key].length, ...srcValue);
      } else {
        gobj[key] = gawk(srcValue, gobj);
      }
    }
  };

  for (const obj of objs) {
    mixer(gobj, obj);
  }

  gobj.__gawk__.resume();

  return gobj;
}
/**
 * Performs a shallow merge of one or more objects into the specified gawk object.
 *
 * @param {...Object} objs - The destination object followed by one or more objects to merge in.
 * @returns {Object}
 */


function merge(...objs) {
  return mix(objs);
}
/**
 * Performs a deep merge of one or more objects into the specified gawk object.
 *
 * @param {...Object} objs - The destination object followed by one or more objects to deeply merge in.
 * @returns {Object}
 */


function mergeDeep(...objs) {
  return mix(objs, true);
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbIkVycm9yIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJyZXF1aXJlIiwidmVyc2lvbiIsIkpTT04iLCJwYXJzZSIsImZzIiwicmVhZEZpbGVTeW5jIiwiX19kaXJuYW1lIiwiYnVpbHRJbnMiLCJwcm9jZXNzIiwiZW52IiwiTWF0aCIsIkludGwiLCJwdXNoIiwiUmVmbGVjdCIsImdhd2siLCJ2YWx1ZSIsInBhcmVudCIsInVuZGVmaW5lZCIsImlzR2F3a2VkIiwiVHlwZUVycm9yIiwiRGF0ZSIsImluZGV4T2YiLCJnYXdrZWQiLCJfX2dhd2tfXyIsIlByb3h5Iiwic2V0IiwidGFyZ2V0IiwicHJvcCIsIm5ld1ZhbHVlIiwiY2hhbmdlZCIsImRlc2MiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwYXJlbnRzIiwiZGVsZXRlIiwic2l6ZSIsIkFycmF5IiwiaXNBcnJheSIsIm5vdGlmeSIsImRlbGV0ZVByb3BlcnR5IiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVmaW5lUHJvcGVydHkiLCJsaXN0ZW5lcnMiLCJwcmV2aW91cyIsInF1ZXVlIiwicGF1c2UiLCJTZXQiLCJyZXN1bWUiLCJpbnN0YW5jZSIsImtleSIsIm93bktleXMiLCJvcmlnUG9wIiwicG9wIiwib3JpZ1NoaWZ0Iiwic2hpZnQiLCJvcmlnU3BsaWNlIiwic3BsaWNlIiwib3JpZ1Vuc2hpZnQiLCJ1bnNoaWZ0IiwiZGVmaW5lUHJvcGVydGllcyIsImNvbmZpZ3VyYWJsZSIsIndhc1BhdXNlZCIsIml0ZW0iLCJzdGFydCIsImRlbGV0ZUNvdW50IiwiaXRlbXMiLCJsZW5ndGgiLCJhcnIiLCJpIiwibGVuIiwiYXBwbHkiLCJtYXAiLCJhZGQiLCJtZXJnZSIsIm1lcmdlRGVlcCIsIndhdGNoIiwidW53YXRjaCIsIml0IiwiZmlsdGVyT2JqZWN0IiwiZ29iaiIsImZpbHRlciIsImZvdW5kIiwib2JqIiwiaGFzaFZhbHVlIiwic3RyIiwic3RyaW5naWZ5IiwiaGFzaCIsImNoYXJDb2RlQXQiLCJzb3VyY2UiLCJzdGF0ZSIsImxpc3RlbmVyIiwiZ2V0IiwiV2Vha01hcCIsImNvcHlMaXN0ZW5lcnMiLCJkZXN0Iiwic3JjIiwiY29tcGFyZUZuIiwiTWFwIiwidmlzaXRlZCIsImoiLCJsZW4yIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIndhbGsiLCJxdWlldCIsInZpc2lzdGVkIiwidG1wIiwic3JjVmFsdWUiLCJkZXN0VmFsdWUiLCJhc3NpZ24iLCJkZXN0SXNBcnJheSIsInNyY0lzQXJyYXkiLCJzdWJqZWN0IiwiZyIsIm1peCIsIm9ianMiLCJkZWVwIiwibWl4ZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBS0E7O0FBQ0E7Ozs7QUFOQTtBQUNBLElBQUksQ0FBQ0EsS0FBSyxDQUFDQyxpQkFBWCxFQUE4QjtBQUM3QkMsRUFBQUEsT0FBTyxDQUFDLDZCQUFELENBQVA7QUFDQTs7QUFLRDs7OztBQUlPLE1BQU1DLE9BQU8sR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVdDLFlBQUdDLFlBQUgsQ0FBaUIsR0FBRUMsU0FBVSxrQkFBN0IsRUFBZ0QsT0FBaEQsQ0FBWCxFQUFxRUwsT0FBckY7QUFFUDs7Ozs7O0FBSUEsTUFBTU0sUUFBUSxHQUFHLENBQ2hCQyxPQUFPLENBQUNDLEdBRFEsRUFFaEJDLElBRmdCLEVBR2hCUixJQUhnQixDQUFqQjs7QUFLQSxJQUFJLE9BQU9TLElBQVAsS0FBZ0IsV0FBcEIsRUFBaUM7QUFDaENKLEVBQUFBLFFBQVEsQ0FBQ0ssSUFBVCxDQUFjRCxJQUFkO0FBQ0E7O0FBQ0QsSUFBSSxPQUFPRSxPQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ25DTixFQUFBQSxRQUFRLENBQUNLLElBQVQsQ0FBY0MsT0FBZDtBQUNBO0FBRUQ7Ozs7Ozs7OztBQU9lLFNBQVNDLElBQVQsQ0FBY0MsS0FBZCxFQUFxQkMsTUFBckIsRUFBNkI7QUFDM0MsTUFBSUEsTUFBTSxLQUFLQyxTQUFY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QUFPRCxHQUFHLENBQUNDLElBQUQsRUFBTyxJQUFQLENBQVY7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuaWYgKCFFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSkge1xuXHRyZXF1aXJlKCdzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXInKTtcbn1cblxuaW1wb3J0IGVxdWFsIGZyb20gJ2Zhc3QtZGVlcC1lcXVhbCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuXG4vKipcbiAqIFRoZSBHYXdrIHZlcnNpb24gbnVtYmVyLlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhgJHtfX2Rpcm5hbWV9Ly4uL3BhY2thZ2UuanNvbmAsICd1dGYtOCcpKS52ZXJzaW9uO1xuXG4vKipcbiAqIEEgbGlzdCBvZiBidWlsdC1pbiBvYmplY3RzIHRoYXQgc2hvdWxkIG5vdCBiZSBnYXdrZWQuXG4gKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gKi9cbmNvbnN0IGJ1aWx0SW5zID0gW1xuXHRwcm9jZXNzLmVudixcblx0TWF0aCxcblx0SlNPTlxuXTtcbmlmICh0eXBlb2YgSW50bCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0YnVpbHRJbnMucHVzaChJbnRsKTtcbn1cbmlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0YnVpbHRJbnMucHVzaChSZWZsZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZ2F3ayBvYmplY3QgdGhhdCB3cmFwcyB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gQSB2YWx1ZSB0byBnYXdrLlxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBnYXdrIG9iamVjdC5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8Kn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2F3ayh2YWx1ZSwgcGFyZW50KSB7XG5cdGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiAhaXNHYXdrZWQocGFyZW50KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHBhcmVudCB0byBiZSBnYXdrZWQnKTtcblx0fVxuXG5cdC8vIG9ubHkgb2JqZWN0cyBjYW4gYmUgZ2F3a2VkIGFuZCBjYW4ndCBiZSBhIGJ1aWx0LWluIG9iamVjdFxuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGJ1aWx0SW5zLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGxldCBnYXdrZWQ7XG5cblx0aWYgKHR5cGVvZiB2YWx1ZS5fX2dhd2tfXyA9PT0gJ29iamVjdCcpIHtcblx0XHQvLyBhbHJlYWR5IGdhd2tlZFxuXHRcdGlmICh2YWx1ZSA9PT0gcGFyZW50KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYXJlbnQgbXVzdCBub3QgYmUgdGhlIHNhbWUgb2JqZWN0IGFzIHRoZSB2YWx1ZScpO1xuXHRcdH1cblx0XHRnYXdrZWQgPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHQvLyBnYXdrIGl0IVxuXHRcdGdhd2tlZCA9IG5ldyBQcm94eSh2YWx1ZSwge1xuXHRcdFx0c2V0OiAodGFyZ2V0LCBwcm9wLCBuZXdWYWx1ZSkgPT4ge1xuXHRcdFx0XHRpZiAocHJvcCA9PT0gJ19fZ2F3a19fJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IG92ZXJyaWRlIHByb3BlcnR5IFxcJ19fZ2F3a19fXFwnJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnc2V0dGluZycsIHByb3AsIG5ld1ZhbHVlKTtcblxuXHRcdFx0XHRsZXQgY2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdFx0aWYgKGRlc2MpIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdGFyZ2V0W3Byb3BdICE9PSBuZXdWYWx1ZTtcblx0XHRcdFx0XHRjb25zdCBwYXJlbnRzID0gaXNHYXdrZWQodGFyZ2V0W3Byb3BdKSAmJiB0YXJnZXRbcHJvcF0uX19nYXdrX18ucGFyZW50cztcblx0XHRcdFx0XHRpZiAocGFyZW50cykge1xuXHRcdFx0XHRcdFx0cGFyZW50cy5kZWxldGUoZ2F3a2VkKTtcblx0XHRcdFx0XHRcdGlmICghcGFyZW50cy5zaXplKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwcm9wXS5fX2dhd2tfXy5wYXJlbnRzID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgZGVzdGluYXRpb24gcHJvcGVydHkgaGFzIGEgc2V0dGVyLCB0aGVuIHdlIGNhbid0IGFzc3VtZSB3ZSBuZWVkIHRvXG5cdFx0XHRcdFx0Ly8gZmlyZSBhIGRlbGV0ZVxuXHRcdFx0XHRcdGlmICh0eXBlb2YgZGVzYy5zZXQgIT09ICdmdW5jdGlvbicgJiYgKCFBcnJheS5pc0FycmF5KHRhcmdldCkgfHwgcHJvcCAhPT0gJ2xlbmd0aCcpKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGFyZ2V0W3Byb3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldFtwcm9wXSA9IGdhd2sobmV3VmFsdWUsIGdhd2tlZCk7XG5cblx0XHRcdFx0aWYgKGNoYW5nZWQpIHtcblx0XHRcdFx0XHRub3RpZnkoZ2F3a2VkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0ZGVsZXRlUHJvcGVydHk6ICh0YXJnZXQsIHByb3ApID0+IHtcblx0XHRcdFx0aWYgKHByb3AgPT09ICdfX2dhd2tfXycpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWxldGUgcHJvcGVydHkgXFwnX19nYXdrX19cXCcnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdkZWxldGluZycsIHByb3AsIHRhcmdldFtwcm9wXSk7XG5cblx0XHRcdFx0bGV0IHJlc3VsdCA9IHRydWU7XG5cblx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApKSB7XG5cdFx0XHRcdFx0Y29uc3QgcGFyZW50cyA9IGlzR2F3a2VkKHRhcmdldFtwcm9wXSkgJiYgdGFyZ2V0W3Byb3BdLl9fZ2F3a19fLnBhcmVudHM7XG5cdFx0XHRcdFx0aWYgKHBhcmVudHMpIHtcblx0XHRcdFx0XHRcdHBhcmVudHMuZGVsZXRlKGdhd2tlZCk7XG5cdFx0XHRcdFx0XHRpZiAoIXBhcmVudHMuc2l6ZSkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcHJvcF0uX19nYXdrX18ucGFyZW50cyA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzdWx0ID0gZGVsZXRlIHRhcmdldFtwcm9wXTtcblx0XHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRub3RpZnkoZ2F3a2VkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGdhd2tlZCwgJ19fZ2F3a19fJywge1xuXHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEEgbWFwIG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBjYWxsIGludm9rZSB3aGVuIGEgY2hhbmdlIG9jY3Vycy4gVGhlIGFzc29jaWF0ZWRcblx0XHRcdFx0ICoga2V5IHZhbHVlIGlzIHRoZSBvcHRpb25hbCBmaWx0ZXIgdG8gYXBwbHkgdG8gdGhlIGxpc3RlbmVyLlxuXHRcdFx0XHQgKiBAdHlwZSB7TWFwfVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0bGlzdGVuZXJzOiBudWxsLFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBIGxpc3Qgb2YgYWxsIHRoZSBnYXdrIG9iamVjdCdzIHBhcmVudHMuIFRoZXNlIHBhcmVudHMgYXJlIG5vdGlmaWVkIHdoZW4gYSBjaGFuZ2Vcblx0XHRcdFx0ICogb2NjdXJzLlxuXHRcdFx0XHQgKiBAdHlwZSB7U2V0fVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0cGFyZW50czogbnVsbCxcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQSBtYXAgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIHRoZSBsYXN0IGtub3duIGhhc2ggb2YgdGhlIHN0cmluZ2lmaWVkIHZhbHVlLiBUaGlzXG5cdFx0XHRcdCAqIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGEgZmlsdGVyZWQgd2F0Y2ggc2hvdWxkIGJlIG5vdGlmaWVkLlxuXHRcdFx0XHQgKiBAdHlwZSB7V2Vha01hcH1cblx0XHRcdFx0ICovXG5cdFx0XHRcdHByZXZpb3VzOiBudWxsLFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBIGxpc3Qgb2YgY2hpbGQgb2JqZWN0cyB0aGF0IGFyZSBtb2RpZmllZCB3aGlsZSBwYXVzZWQuXG5cdFx0XHRcdCAqIEB0eXBlIHtTZXR9XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRxdWV1ZTogbnVsbCxcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVGhlIEdhd2sgdmVyc2lvbi4gVGhpcyBpcyBoZWxwZnVsIGZvciBpZGVudGlmeWluZyB0aGUgcmV2aXNpb24gb2YgdGhpcyBpbnRlcm5hbFxuXHRcdFx0XHQgKiBzdHJ1Y3R1cmUuXG5cdFx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR2ZXJzaW9uLFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBEaXNwYXRjaGVzIGNoYW5nZSBub3RpZmljYXRpb25zIHRvIHRoZSBsaXN0ZW5lcnMuXG5cdFx0XHRcdCAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBpdCB3YXMgYWxyZWFkeSBwYXVzZWQuXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRwYXVzZSgpIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMucXVldWUpIHtcblx0XHRcdFx0XHRcdHRoaXMucXVldWUgPSBuZXcgU2V0KCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBVbnBhdXNlcyB0aGUgZ2F3ayBub3RpZmljYXRpb25zIGFuZCBzZW5kcyBvdXQgYW55IHBlbmRpbmcgbm90aWZpY2F0aW9ucy5cblx0XHRcdFx0ICovXG5cdFx0XHRcdHJlc3VtZSgpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5xdWV1ZSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlO1xuXHRcdFx0XHRcdFx0dGhpcy5xdWV1ZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGluc3RhbmNlIG9mIHF1ZXVlKSB7XG5cdFx0XHRcdFx0XHRcdG5vdGlmeShnYXdrZWQsIGluc3RhbmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGdhd2sgYW55IG9iamVjdCBwcm9wZXJ0aWVzXG5cdFx0Zm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKGdhd2tlZCkpIHtcblx0XHRcdGlmIChrZXkgIT09ICdfX2dhd2tfXycgJiYgZ2F3a2VkW2tleV0gJiYgdHlwZW9mIGdhd2tlZFtrZXldID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRnYXdrZWRba2V5XSA9IGdhd2soZ2F3a2VkW2tleV0sIGdhd2tlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHQvLyBzb21lIGFycmF5IGZ1bmN0aW9ucyBkbyBub3QgaW52b2tlIHRoZSBkZWxldGUgaGFuZGxlciwgc28gd2UgbmVlZCB0byBvdmVycmlkZSB0aGVcblx0XHRcdC8vIG1ldGhvZCBhbmQgZG8gaXQgb3Vyc2VsdmVzXG5cdFx0XHRjb25zdCBvcmlnUG9wID0gdmFsdWUucG9wO1xuXHRcdFx0Y29uc3Qgb3JpZ1NoaWZ0ID0gdmFsdWUuc2hpZnQ7XG5cdFx0XHRjb25zdCBvcmlnU3BsaWNlID0gdmFsdWUuc3BsaWNlO1xuXHRcdFx0Y29uc3Qgb3JpZ1Vuc2hpZnQgPSB2YWx1ZS51bnNoaWZ0O1xuXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyh2YWx1ZSwge1xuXHRcdFx0XHRwb3A6IHtcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHBvcCgpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHdhc1BhdXNlZCA9IHRoaXMuX19nYXdrX18ucGF1c2UoKTtcblx0XHRcdFx0XHRcdGNvbnN0IGl0ZW0gPSBvcmlnUG9wLmNhbGwodGhpcyk7XG5cdFx0XHRcdFx0XHR3YXNQYXVzZWQgfHwgdGhpcy5fX2dhd2tfXy5yZXN1bWUoKTtcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRzaGlmdDoge1xuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB3YXNQYXVzZWQgPSB0aGlzLl9fZ2F3a19fLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHRjb25zdCBpdGVtID0gb3JpZ1NoaWZ0LmNhbGwodGhpcyk7XG5cdFx0XHRcdFx0XHR3YXNQYXVzZWQgfHwgdGhpcy5fX2dhd2tfXy5yZXN1bWUoKTtcblx0XHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRzcGxpY2U6IHtcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB3YXNQYXVzZWQgPSB0aGlzLl9fZ2F3a19fLnBhdXNlKCk7XG5cblx0XHRcdFx0XHRcdGlmIChzdGFydCAhPT0gdW5kZWZpbmVkICYmIGRlbGV0ZUNvdW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlQ291bnQgPSB0aGlzLmxlbmd0aCAtIHN0YXJ0O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCBhcnIgPSBvcmlnU3BsaWNlLmNhbGwodGhpcywgc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pdGVtcyk7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnQgKyBpdGVtcy5sZW5ndGg7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzW2ldICYmIHR5cGVvZiB0aGlzW2ldID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbaV0gPSBnYXdrKHRoaXNbaV0sIHRoaXMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGlzR2F3a2VkKGl0ZW0pICYmIGl0ZW0uX19nYXdrX18ucGFyZW50cykge1xuXHRcdFx0XHRcdFx0XHRcdGl0ZW0uX19nYXdrX18ucGFyZW50cy5kZWxldGUodGhpcyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0d2FzUGF1c2VkIHx8IHRoaXMuX19nYXdrX18ucmVzdW1lKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYXJyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1bnNoaWZ0OiB7XG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KC4uLml0ZW1zKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB3YXNQYXVzZWQgPSB0aGlzLl9fZ2F3a19fLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHRjb25zdCBsZW4gPSBvcmlnVW5zaGlmdC5hcHBseSh0aGlzLCBpdGVtcy5tYXAoaXRlbSA9PiBnYXdrKGl0ZW0sIHRoaXMpKSk7XG5cdFx0XHRcdFx0XHR3YXNQYXVzZWQgfHwgdGhpcy5fX2dhd2tfXy5yZXN1bWUoKTtcblx0XHRcdFx0XHRcdHJldHVybiBsZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRpZiAocGFyZW50KSB7XG5cdFx0aWYgKCFnYXdrZWQuX19nYXdrX18ucGFyZW50cykge1xuXHRcdFx0Z2F3a2VkLl9fZ2F3a19fLnBhcmVudHMgPSBuZXcgU2V0KCk7XG5cdFx0fVxuXHRcdGdhd2tlZC5fX2dhd2tfXy5wYXJlbnRzLmFkZChwYXJlbnQpO1xuXHR9XG5cblx0cmV0dXJuIGdhd2tlZDtcbn1cblxuZ2F3ay5pc0dhd2tlZCAgPSBpc0dhd2tlZDtcbmdhd2subWVyZ2UgICAgID0gbWVyZ2U7XG5nYXdrLnNldCAgICAgICA9IHNldDtcbmdhd2subWVyZ2VEZWVwID0gbWVyZ2VEZWVwO1xuZ2F3ay53YXRjaCAgICAgPSB3YXRjaDtcbmdhd2sudW53YXRjaCAgID0gdW53YXRjaDtcblxuZXhwb3J0IHsgZ2F3ayBhcyBnYXdrIH07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgc3BlY2lmaWVkIHZhcmlhYmxlIGlzIGdhd2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGl0IC0gVGhlIHZhcmlhYmxlIHRvIGNoZWNrLlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0dhd2tlZChpdCkge1xuXHRyZXR1cm4gISEoaXQgJiYgdHlwZW9mIGl0ID09PSAnb2JqZWN0JyAmJiBpdC5fX2dhd2tfXyAmJiB0eXBlb2YgaXQuX19nYXdrX18gPT09ICdvYmplY3QnKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXJzIHRoZSBzcGVjaWZpZWQgZ2F3ayBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGdvYmogLSBBIGdhd2tlZCBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBmaWx0ZXIgLSBUaGUgZmlsdGVyIHRvIGFwcGx5IHRvIHRoZSBnYXdrZWQgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZmlsdGVyT2JqZWN0KGdvYmosIGZpbHRlcikge1xuXHRsZXQgZm91bmQgPSB0cnVlO1xuXHRsZXQgb2JqID0gZ29iajtcblxuXHQvLyBmaW5kIHRoZSB2YWx1ZSB3ZSdyZSBpbnRlcmVzdGVkIGluXG5cdGZvciAobGV0IGkgPSAwLCBsZW4gPSBmaWx0ZXIubGVuZ3RoOyBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgaSA8IGxlbjsgaSsrKSB7XG5cdFx0aWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBmaWx0ZXJbaV0pKSB7XG5cdFx0XHRmb3VuZCA9IGZhbHNlO1xuXHRcdFx0b2JqID0gdW5kZWZpbmVkO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdG9iaiA9IG9ialtmaWx0ZXJbaV1dO1xuXHR9XG5cblx0cmV0dXJuIHsgZm91bmQsIG9iaiB9O1xufVxuXG4vKipcbiAqIEhhc2hlcyBhIHZhbHVlIHF1aWNrIGFuZCBkaXJ0eS5cbiAqXG4gKiBAcGFyYW0geyp9IGl0IC0gQSB2YWx1ZSB0byBoYXNoLlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gaGFzaFZhbHVlKGl0KSB7XG5cdGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KGl0KSB8fCAnJztcblx0bGV0IGhhc2ggPSA1MzgxO1xuXHRsZXQgaSA9IHN0ci5sZW5ndGg7XG5cdHdoaWxlIChpKSB7XG5cdFx0aGFzaCA9IGhhc2ggKiAzMyBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG5cdH1cblx0cmV0dXJuIGhhc2ggPj4+IDA7XG59XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBjaGFuZ2Ugbm90aWZpY2F0aW9ucyB0byB0aGUgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBnb2JqIC0gVGhlIGdhd2tlZCBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gW3NvdXJjZV0gLSBUaGUgZ2F3ayBvYmplY3QgdGhhdCB3YXMgbW9kaWZpZWQuXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeShnb2JqLCBzb3VyY2UpIHtcblx0Y29uc3Qgc3RhdGUgPSBnb2JqLl9fZ2F3a19fO1xuXG5cdGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHNvdXJjZSA9IGdvYmo7XG5cdH1cblxuXHQvLyBpZiB3ZSdyZSBwYXVzZWQsIGFkZCB0aGlzIG9iamVjdCB0byB0aGUgbGlzdCBvZiBvYmplY3RzIHRoYXQgbWF5IGhhdmUgY2hhbmdlZFxuXHRpZiAoc3RhdGUucXVldWUpIHtcblx0XHRzdGF0ZS5xdWV1ZS5hZGQoZ29iaik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gbm90aWZ5IGFsbCBvZiB0aGlzIG9iamVjdCdzIGxpc3RlbmVyc1xuXHRpZiAoc3RhdGUubGlzdGVuZXJzKSB7XG5cdFx0Zm9yIChjb25zdCBbIGxpc3RlbmVyLCBmaWx0ZXIgXSBvZiBzdGF0ZS5saXN0ZW5lcnMpIHtcblx0XHRcdGlmIChmaWx0ZXIpIHtcblx0XHRcdFx0Y29uc3QgeyBmb3VuZCwgb2JqIH0gPSBmaWx0ZXJPYmplY3QoZ29iaiwgZmlsdGVyKTtcblxuXHRcdFx0XHQvLyBjb21wdXRlIHRoZSBoYXNoIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZVxuXHRcdFx0XHRjb25zdCBoYXNoID0gaGFzaFZhbHVlKG9iaik7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHZhbHVlIGNoYW5nZWRcblx0XHRcdFx0aWYgKChmb3VuZCAmJiAhc3RhdGUucHJldmlvdXMpIHx8IChzdGF0ZS5wcmV2aW91cyAmJiBoYXNoICE9PSBzdGF0ZS5wcmV2aW91cy5nZXQobGlzdGVuZXIpKSkge1xuXHRcdFx0XHRcdGxpc3RlbmVyKG9iaiwgc291cmNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghc3RhdGUucHJldmlvdXMpIHtcblx0XHRcdFx0XHRzdGF0ZS5wcmV2aW91cyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS5wcmV2aW91cy5zZXQobGlzdGVuZXIsIGhhc2gpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGlzdGVuZXIoZ29iaiwgc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBub3RpZnkgYWxsIG9mIHRoaXMgb2JqZWN0J3MgcGFyZW50c1xuXHRpZiAoc3RhdGUucGFyZW50cykge1xuXHRcdGZvciAoY29uc3QgcGFyZW50IG9mIHN0YXRlLnBhcmVudHMpIHtcblx0XHRcdG5vdGlmeShwYXJlbnQsIHNvdXJjZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQ29waWVzIGxpc3RlbmVycyBmcm9tIGEgc291cmNlIGdhd2tlZCBvYmplY3Qgb3QgYSBkZXN0aW5hdGlvbiBnYXdrZWQgb2JqZWN0LiBOb3RlIHRoYXQgdGhlXG4gKiBhcmd1bWVudHMgbXVzdCBib3RoIGJlIG9iamVjdHMgYW5kIG9ubHkgdGhlIGBkZXN0YCBpcyByZXF1aXJlZCB0byBhbHJlYWR5IGJlIGdhd2tlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGVzdCAtIEEgZ2F3a2VkIG9iamVjdCB0byBjb3B5IHRoZSBsaXN0ZW5lcnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gc3JjIC0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIGxpc3RlbmVycyBmcm9tLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVGbl0gLSBEb3VibGVzIHVwIGFzIGEgZGVlcCBjb3B5IGZsYWcgYW5kIGEgZnVuY3Rpb24gdG8gY2FsbCB0byBjb21wYXJlXG4gKiBhIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gYXJyYXkgZWxlbWVudHMgdG8gY2hlY2sgaWYgdGhleSBhcmUgdGhlIHNhbWUuXG4gKi9cbmZ1bmN0aW9uIGNvcHlMaXN0ZW5lcnMoZGVzdCwgc3JjLCBjb21wYXJlRm4pIHtcblx0aWYgKGlzR2F3a2VkKHNyYykgJiYgc3JjLl9fZ2F3a19fLmxpc3RlbmVycykge1xuXHRcdGlmIChkZXN0Ll9fZ2F3a19fLmxpc3RlbmVycykge1xuXHRcdFx0Zm9yIChjb25zdCBbIGxpc3RlbmVyLCBmaWx0ZXIgXSBvZiBzcmMuX19nYXdrX18ubGlzdGVuZXJzKSB7XG5cdFx0XHRcdGRlc3QuX19nYXdrX18ubGlzdGVuZXJzLnNldChsaXN0ZW5lciwgZmlsdGVyKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdC5fX2dhd2tfXy5saXN0ZW5lcnMgPSBuZXcgTWFwKHNyYy5fX2dhd2tfXy5saXN0ZW5lcnMpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghY29tcGFyZUZuKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKEFycmF5LmlzQXJyYXkoZGVzdCkpIHtcblx0XHRjb25zdCB2aXNpdGVkID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGxlbiA9IGRlc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChkZXN0W2ldICE9PSBudWxsICYmIHR5cGVvZiBkZXN0W2ldID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHQvLyB0cnkgdG8gZmluZCBhIG1hdGNoIGluIHNyY1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbGVuMiA9IHNyYy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0XHRpZiAoIXZpc2l0ZWRbal0gJiYgc3JjW2pdICE9PSBudWxsICYmIHR5cGVvZiBzcmNbal0gPT09ICdvYmplY3QnICYmIGNvbXBhcmVGbihkZXN0W2ldLCBzcmNbal0pKSB7XG5cdFx0XHRcdFx0XHR2aXNpdGVkW2pdID0gMTtcblx0XHRcdFx0XHRcdGNvcHlMaXN0ZW5lcnMoZGVzdFtpXSwgc3JjW2pdLCBjb21wYXJlRm4pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlc3QpKSB7XG5cdFx0aWYgKGtleSA9PT0gJ19fZ2F3a19fJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKGRlc3Rba2V5XSAmJiB0eXBlb2YgZGVzdFtrZXldID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29weUxpc3RlbmVycyhkZXN0W2tleV0sIHNyY1trZXldLCBjb21wYXJlRm4pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIGZvciByZXBsYWNpbmcgdGhlIGNvbnRlbnRzIG9mIG9uZSBnYXdrZWQgb2JqZWN0IHdpdGggYW5vdGhlci4gSXQgdGFrZXMgY2FyZSBvZlxuICogcmVjdXJzaXZlbHkgZ2F3a2luZyBhbGwgZGVjZW5kaW5nIG9iamVjdHMgYW5kIGNvcHlpbmcgbGlzdGVuZXJzIG92ZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRlc3QgLSBUaGUgZGVzdGluYXRpb24gZ2F3a2VkIG9iamVjdCBvciBhcnJheS5cbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBzcmMgLSBUaGUgc291cmNlIG9iamVjdCBvciBhcnJheS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlRm5dIC0gQSBmdW5jdGlvbiB0byBjYWxsIHRvIGNvbXBhcmUgYSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHRvIGNoZWNrXG4gKiBpZiB0aGV5IGFyZSB0aGUgc2FtZS5cbiAqIEByZXR1cm5zIHtPYmplY3R8QXJyYXl9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIGdhd2tlZCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQoZGVzdCwgc3JjLCBjb21wYXJlRm4pIHtcblx0aWYgKCFkZXN0IHx8IHR5cGVvZiBkZXN0ICE9PSAnb2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGRlc3RpbmF0aW9uIHRvIGJlIGFuIG9iamVjdCcpO1xuXHR9XG5cblx0aWYgKCFzcmMgfHwgdHlwZW9mIHNyYyAhPT0gJ29iamVjdCcpIHtcblx0XHQvLyBzb3VyY2UgaXMgbm90IGFuIG9iamVjdCwgc28ganVzdCByZXR1cm4gaXRcblx0XHRyZXR1cm4gc3JjO1xuXHR9XG5cblx0aWYgKCFjb21wYXJlRm4pIHtcblx0XHRjb21wYXJlRm4gPSAoZGVzdCwgc3JjKSA9PiB7XG5cdFx0XHQvLyBub3RlOiB3ZSBwdXJwb3NlbHkgZG8gbm9uLXN0cmljdCBlcXVhbGl0eVxuXHRcdFx0cmV0dXJuIGVxdWFsKGRlc3QsIHNyYyk7XG5cdFx0fTtcblx0fSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZUZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgY29tcGFyZSBjYWxsYmFjayB0byBiZSBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHRjb25zdCB3YWxrID0gKGRlc3QsIHNyYywgcXVpZXQsIGNoYW5nZWQpID0+ICB7XG5cdFx0Ly8gc3VzcGVuZCBub3RpZmljYXRpb25zIGlmIHRoZSBkZXN0IGlzIGEgbmV3IGdhd2sgb2JqZWN0XG5cdFx0bGV0IHdhc1BhdXNlZCA9IGZhbHNlO1xuXHRcdGlmICghcXVpZXQpIHtcblx0XHRcdHdhc1BhdXNlZCA9IGRlc3QuX19nYXdrX18ucGF1c2UoKTtcblx0XHR9XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG5cdFx0XHQvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShkZXN0KSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBpcyBhbiBhcnJheSBhbmQgZXhwZWN0ZWQgZGVzdCB0byBhbHNvIGJlIGFuIGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZpc2lzdGVkID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aWYgKHNyY1tpXSAhPT0gbnVsbCAmJiB0eXBlb2Ygc3JjW2ldID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHNyY1tpXSA9IGdhd2soc3JjW2ldKTtcblx0XHRcdFx0XHQvLyB0cnkgdG8gZmluZCBhIG1hdGNoIGluIGRlc3Rcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbGVuMiA9IGRlc3QubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXZpc2lzdGVkW2pdICYmIGRlc3Rbal0gIT09IG51bGwgJiYgdHlwZW9mIGRlc3Rbal0gPT09ICdvYmplY3QnICYmIGNvbXBhcmVGbihkZXN0W2pdLCBzcmNbaV0pKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2lzdGVkW2pdID0gMTtcblx0XHRcdFx0XHRcdFx0Y29weUxpc3RlbmVycyhzcmNbaV0sIGRlc3Rbal0sIGNvbXBhcmVGbik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRkZXN0LnNwbGljZSgwLCBkZXN0Lmxlbmd0aCwgLi4uc3JjKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcblx0XHRcdGlmICghZGVzdCB8fCB0eXBlb2YgZGVzdCAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgaXMgYW4gb2JqZWN0IGFuZCBleHBlY3RlZCBkZXN0IHRvIGFsc28gYmUgYW4gb2JqZWN0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRtcCA9IHt9O1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpKSB7XG5cdFx0XHRcdGlmIChrZXkgPT09ICdfX2dhd2tfXycpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHNyY1ZhbHVlID0gc3JjW2tleV07XG5cblx0XHRcdFx0Ly8gaWYgdGhlIHNvdXJjZSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0LCByZXR1cm4gaXQgbm93XG5cdFx0XHRcdGlmIChzcmNWYWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2Ygc3JjVmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dG1wW2tleV0gPSBzcmNWYWx1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNyZWF0ZSBhIG5ldyBkZXN0IG9iamVjdCB0byBjb3B5IHRoZSBzb3VyY2UgaW50b1xuXHRcdFx0XHRjb25zdCBkZXN0VmFsdWUgPSBnYXdrKEFycmF5LmlzQXJyYXkoc3JjVmFsdWUpID8gW10gOiB7fSk7XG5cdFx0XHRcdHRtcFtrZXldID0gd2FsayhkZXN0VmFsdWUsIHNyY1ZhbHVlLCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3QsIGtleSkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcnVuZSB0aGUgZXhpc3Rpbmcgb2JqZWN0LCB0aGVuIGNvcHkgYWxsIHRoZSBwcm9wZXJ0aWVzIGZyb20gb3VyIHRlbXAgb2JqZWN0XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZXN0KSkge1xuXHRcdFx0XHRpZiAoa2V5ICE9PSAnX19nYXdrX18nKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGRlc3Rba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0T2JqZWN0LmFzc2lnbihkZXN0LCB0bXApO1xuXHRcdH1cblxuXHRcdC8vIGNvcHkgdGhlIGxpc3RlbmVyc1xuXHRcdGNvcHlMaXN0ZW5lcnMoZGVzdCwgc3JjKTtcblxuXHRcdC8vIGRpZCBkZXN0IHJlYWxseSBjaGFuZ2U/IGlmIG5vdCwgcmVtb3ZlIGl0IGZyb20gdGhlIHF1ZXVlXG5cdFx0aWYgKCFjaGFuZ2VkICYmIGRlc3QuX19nYXdrX18ucXVldWUpIHtcblx0XHRcdGRlc3QuX19nYXdrX18ucXVldWUuZGVsZXRlKGRlc3QpO1xuXHRcdH1cblxuXHRcdC8vIHJlc3VtZSBhbmQgc2VuZCBvdXQgY2hhbmdlIG5vdGlmaWNhdGlvbnNcblx0XHR3YXNQYXVzZWQgfHwgZGVzdC5fX2dhd2tfXy5yZXN1bWUoKTtcblxuXHRcdHJldHVybiBkZXN0O1xuXHR9O1xuXG5cdGNvbnN0IGRlc3RJc0FycmF5ID0gQXJyYXkuaXNBcnJheShkZXN0KTtcblx0Y29uc3Qgc3JjSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc3JjKTtcblxuXHRpZiAoZGVzdElzQXJyYXkgIT09IHNyY0lzQXJyYXkpIHtcblx0XHQvLyB0aGUgdHlwZSBjaGFuZ2VkIGFuZCB0aGVyZSdzIG5vIGNsZWFyIHdheSB0byBjb21wYXJlIHRoZW0sIHNvIGp1c3QgcmV0dXJuIGEgZ2F3a2VkIGNsb25lXG5cdFx0Ly8gb2YgdGhlIHNvdXJjZVxuXHRcdGRlc3QgPSBzcmNJc0FycmF5ID8gW10gOiB7fTtcblx0fVxuXG5cdGNvbnN0IGdhd2tlZCA9IGlzR2F3a2VkKGRlc3QpO1xuXG5cdHJldHVybiB3YWxrKGdhd2tlZCA/IGRlc3QgOiBnYXdrKGRlc3QpLCBzcmMsICFnYXdrZWQsICFlcXVhbChkZXN0LCBzcmMpKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHNwZWNpZmllZCBvYmplY3Qgb3IgYW55IG9mIGl0cyBwcm9wZXJ0aWVzL2VsZW1lbnRzIGFyZVxuICogY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gc3ViamVjdCAtIFRoZSBvYmplY3QgdG8gd2F0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gW2ZpbHRlcl0gLSBBIHByb3BlcnR5IG5hbWUgb3IgYXJyYXkgb2YgbmVzdGVkIHByb3BlcnRpZXMgdG8gd2F0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gc29tZXRoaW5nIGNoYW5nZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fEFycmF5fSBSZXR1cm5zIGEgZ2F3a2VkIG9iamVjdCBvciBhcnJheSBkZXBlbmRpbmcgb24gdGhlIGlucHV0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoKHN1YmplY3QsIGZpbHRlciwgbGlzdGVuZXIpIHtcblx0aWYgKCFpc0dhd2tlZChzdWJqZWN0KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHN1YmplY3QgdG8gYmUgZ2F3a2VkJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGxpc3RlbmVyID0gZmlsdGVyO1xuXHRcdGZpbHRlciA9IG51bGw7XG5cdH1cblxuXHRpZiAoZmlsdGVyKSB7XG5cdFx0aWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRmaWx0ZXIgPSBbIGZpbHRlciBdO1xuXHRcdH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgZmlsdGVyIHRvIGJlIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MnKTtcblx0XHR9XG5cdH1cblxuXHRpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbicpO1xuXHR9XG5cblx0aWYgKCFzdWJqZWN0Ll9fZ2F3a19fLmxpc3RlbmVycykge1xuXHRcdHN1YmplY3QuX19nYXdrX18ubGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXHR9XG5cdHN1YmplY3QuX19nYXdrX18ubGlzdGVuZXJzLnNldChsaXN0ZW5lciwgZmlsdGVyKTtcblxuXHRpZiAoZmlsdGVyKSB7XG5cdFx0Y29uc3QgeyBmb3VuZCwgb2JqIH0gPSBmaWx0ZXJPYmplY3Qoc3ViamVjdCwgZmlsdGVyKTtcblx0XHRpZiAoZm91bmQpIHtcblx0XHRcdGNvbnN0IGhhc2ggPSBoYXNoVmFsdWUob2JqKTtcblx0XHRcdGlmICghc3ViamVjdC5fX2dhd2tfXy5wcmV2aW91cykge1xuXHRcdFx0XHRzdWJqZWN0Ll9fZ2F3a19fLnByZXZpb3VzID0gbmV3IFdlYWtNYXAoKTtcblx0XHRcdH1cblx0XHRcdHN1YmplY3QuX19nYXdrX18ucHJldmlvdXMuc2V0KGxpc3RlbmVyLCBoYXNoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3ViamVjdDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgc3BlY2lmaWVkIGdhd2tlZCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHN1YmplY3QgLSBUaGUgb2JqZWN0IHRvIHVud2F0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbGlzdGVuZXJdIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBzb21ldGhpbmcgY2hhbmdlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R8QXJyYXl9IFJldHVybnMgYSBnYXdrZWQgb2JqZWN0IG9yIGFycmF5IGRlcGVuZGluZyBvbiB0aGUgaW5wdXQgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53YXRjaChzdWJqZWN0LCBsaXN0ZW5lcikge1xuXHRpZiAoIWlzR2F3a2VkKHN1YmplY3QpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc3ViamVjdCB0byBiZSBnYXdrZWQnKTtcblx0fVxuXG5cdGlmIChsaXN0ZW5lciAmJiB0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHRjb25zdCBnID0gc3ViamVjdC5fX2dhd2tfXztcblxuXHRpZiAoZy5saXN0ZW5lcnMpIHtcblx0XHRpZiAobGlzdGVuZXIpIHtcblx0XHRcdGcubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG5cdFx0XHRpZiAoZy5wcmV2aW91cykge1xuXHRcdFx0XHRnLnByZXZpb3VzLmRlbGV0ZShsaXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG5cdFx0XHRmb3IgKGNvbnN0IFsgbGlzdGVuZXIsIGZpbHRlciBdIG9mIGcubGlzdGVuZXJzKSB7XG5cdFx0XHRcdGcubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG5cdFx0XHRcdGlmIChnLnByZXZpb3VzKSB7XG5cdFx0XHRcdFx0Zy5wcmV2aW91cy5kZWxldGUobGlzdGVuZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFnLmxpc3RlbmVycy5zaXplKSB7XG5cdFx0XHRnLmxpc3RlbmVycyA9IG51bGw7XG5cdFx0XHRnLnByZXZpb3VzID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3ViamVjdDtcbn1cblxuLyoqXG4gKiBNaXhlcyBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGdhd2tlZCBvYmplY3RzIGludG8gdGhlIHNwZWNpZmllZCBnYXdrZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IG9ianMgLSBBbiBhcnJheSBvZiBvYmplY3RzIG9yIGdhd2tlZCBvYmplY3RzLlxuICogQHBhcmFtIHtCb29sZWFufSBbZGVlcD1mYWxzZV0gLSBXaGVuIHRydWUsIG1peGVzIHN1Ym9iamVjdHMgaW50byBlYWNoIG90aGVyLlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWl4KG9ianMsIGRlZXApIHtcblx0Y29uc3QgZ29iaiA9IGdhd2sob2Jqcy5zaGlmdCgpKTtcblx0aWYgKCFpc0dhd2tlZChnb2JqKSB8fCBBcnJheS5pc0FycmF5KGdvYmopKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgZGVzdGluYXRpb24gdG8gYmUgYSBnYXdrZWQgb2JqZWN0Jyk7XG5cdH1cblxuXHRpZiAoIW9ianMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGdvYmo7XG5cdH1cblxuXHQvLyB2YWxpZGF0ZSB0aGUgb2JqZWN0cyBhcmUgZ29vZFxuXHRmb3IgKGNvbnN0IG9iaiBvZiBvYmpzKSB7XG5cdFx0aWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBtZXJnZSBzb3VyY2UgdG8gYmUgYW4gb2JqZWN0Jyk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gd2UgbmVlZCB0byBkZXRhY2ggdGhlIHBhcmVudCBhbmQgYWxsIGxpc3RlbmVycyBzbyB0aGF0IHRoZXkgd2lsbCBiZSBub3RpZmllZCBhZnRlciBldmVyeXRoaW5nXG5cdC8vIGhhcyBiZWVuIG1lcmdlZFxuXHRnb2JqLl9fZ2F3a19fLnBhdXNlKCk7XG5cblx0LyoqXG5cdCAqIE1peCBhbiBvYmplY3Qgb3IgZ2F3a2VkIG9iamVjdCBpbnRvIGEgZ2F3a2VkIG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGdvYmogLSBUaGUgZGVzdGluYXRpb24gZ2F3a2VkIG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IHNyYyAtIFRoZSBzb3VyY2Ugb2JqZWN0IHRvIGNvcHkgZnJvbS5cblx0ICovXG5cdGNvbnN0IG1peGVyID0gKGdvYmosIHNyYykgPT4ge1xuXHRcdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNyYykpIHtcblx0XHRcdGlmIChrZXkgPT09ICdfX2dhd2tfXycpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNyY1ZhbHVlID0gc3JjW2tleV07XG5cblx0XHRcdGlmIChkZWVwICYmIHNyY1ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBzcmNWYWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc3JjVmFsdWUpKSB7XG5cdFx0XHRcdGlmICghaXNHYXdrZWQoZ29ialtrZXldKSkge1xuXHRcdFx0XHRcdGdvYmpba2V5XSA9IGdhd2soe30sIGdvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1peGVyKGdvYmpba2V5XSwgc3JjVmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGdvYmpba2V5XSkgJiYgQXJyYXkuaXNBcnJheShzcmNWYWx1ZSkpIHtcblx0XHRcdFx0Ly8gb3ZlcndyaXRlIGRlc3RpbmF0aW9uIHdpdGggbmV3IHZhbHVlc1xuXHRcdFx0XHRnb2JqW2tleV0uc3BsaWNlKDAsIGdvYmpba2V5XS5sZW5ndGgsIC4uLnNyY1ZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdvYmpba2V5XSA9IGdhd2soc3JjVmFsdWUsIGdvYmopO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRmb3IgKGNvbnN0IG9iaiBvZiBvYmpzKSB7XG5cdFx0bWl4ZXIoZ29iaiwgb2JqKTtcblx0fVxuXG5cdGdvYmouX19nYXdrX18ucmVzdW1lKCk7XG5cblx0cmV0dXJuIGdvYmo7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzaGFsbG93IG1lcmdlIG9mIG9uZSBvciBtb3JlIG9iamVjdHMgaW50byB0aGUgc3BlY2lmaWVkIGdhd2sgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmpzIC0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBvYmplY3RzIHRvIG1lcmdlIGluLlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKC4uLm9ianMpIHtcblx0cmV0dXJuIG1peChvYmpzKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgbWVyZ2Ugb2Ygb25lIG9yIG1vcmUgb2JqZWN0cyBpbnRvIHRoZSBzcGVjaWZpZWQgZ2F3ayBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9ianMgLSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIG9iamVjdHMgdG8gZGVlcGx5IG1lcmdlIGluLlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVlcCguLi5vYmpzKSB7XG5cdHJldHVybiBtaXgob2JqcywgdHJ1ZSk7XG59XG4iXSwiZmlsZSI6ImluZGV4LmpzIn0=
